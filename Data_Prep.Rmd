---
title: "Data_Preperation"
author: "Martin Krahl"
date: "2023-07-31"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
library(dplyr)
library(lubridate)
library(ggplot2)
library(gridExtra)
library(tidyr)
library(data.table)
library(zoo)
library(timeDate)
library(corrplot)
library(caret)
library(stringr)
library(randomForest)
```
#Load Data
```{r}
df_Leads <- readxl::read_xlsx('./data/TermPaperChallenge.xlsx', sheet <- 'Leads')
df_Ads <- readxl::read_xlsx('./data/TermPaperChallenge.xlsx', sheet <- 'Ads')
df_Traffic <- readxl::read_xlsx('./data/TermPaperChallenge.xlsx', sheet <- 'WebsiteTraffic')
df_Macro <- readxl::read_xlsx('./data/TermPaperChallenge.xlsx', sheet <- 'Macro')
```

# 1. Data Preprocessing (Leads Data)
```{r}
#Deleting Outliers
#Some observations have uniquely high value. These must be deleted to not effect the regression too much

#The EDA showed that the number of Leads is increasing over time. To allow for a flexible mean and sd, the measures are calculated by year. 
df_Leads <- df_Leads %>%
  mutate(Year = format(DateCreated, "%Y"))

summary_data <- df_Leads %>%
  group_by(Year, Type)%>%
  summarise(Mean_NextDayLeads = mean(NextDayLeads),
            Sd_NextDayLeads = sd(NextDayLeads),
            Threshold = Mean_NextDayLeads + 4 * Sd_NextDayLeads) %>%  #Threshold is determined to begin 4 Sd over the Mean
  select(Year, Type, Threshold)

df_Leads <- merge(df_Leads, summary_data, by = c("Year", "Type"))

df_Leads <- df_Leads %>%
  filter( DateCreated > max(df_Leads$DateCreated) %m-% months(2) | Threshold > NextDayLeads) %>%
  select(-Year, -Threshold)

# Add columns NextDayLeads for each Manual and Website with date 
data <- df_Leads %>%
  pivot_wider(names_from = Type, values_from = NextDayLeads) %>%
  rename(Date = DateCreated, #Rename columns
         NextDayLeads.Manual = Manual,
         NextDayLeads.Website = Website)

```

# 2. Data Preproccesing (Traffic Data)
```{r}
#The Traffic Data started late. The first rows which are wrongfully zero have to be deleted. 
df_Traffic <- df_Traffic[which(df_Traffic$Visits != 0)[1]:nrow(df_Traffic), ]
```

# 3. Data Prepoccessing (Macro-Economic Data)
```{r}
df_Macro <- df_Macro %>%
  complete(Date = seq(min(Date), max(Date), by = "day"))

#Fill the Macro-Economic Data with the previous values in case of empty values (weekends)
df_Macro <- df_Macro %>%
  fill(DAX,
       `Bundesanleihen 10 Year`,
       `Gold (in Euro)`,
       `German Electricity Price`,
       `Oilprice (Brent)`,
       `Federal Funds Futures (Expectations in 12 Months)`,
       `Job Postings in Germany on Indeed`, 
       `US Economic Policy Uncertainty Index`,
       `Baltic Exchange Dry Index (BDI)`,
       `Yield Spread 10Y - 2Y (Germany)`, 
       `Yield Spread 10Y - 2Y (US)`,
       `Exchange Rate (1 USD = X EUR)`, 
       `US Corporate Bonds - Investment Grade - Option Adjusted Spread`,
       .direction = "down")

#Converting/Replacing special characters
colnames(df_Macro) <- gsub(" ", "_", colnames(df_Macro))
colnames(df_Macro) <- gsub("[\\(\\)=\\-]", "", colnames(df_Macro))
```

### 4. Feature Engineering
```{r}
#Idea: Add new features and select relevant ones later.

# group ad data by day and sum up clicks, impressions and money spend per day
df_Ads <- df_Ads %>%
  group_by(Date) %>%
  summarise(AdImpressions = sum(Impressions),
            AdClicks= sum(Clicks),
            AdSpend= sum(Spend))

# Add 7 day rolling Average for Impressions, Clicks and Spend.
df_Ads = cbind(df_Ads, AdImpressions.7RA = rollapplyr(df_Ads$AdImpressions, 7, mean, partial = TRUE)) 
df_Ads = cbind(df_Ads, AdClicks.7RA = rollapplyr(df_Ads$AdClicks, 7, mean, partial = TRUE)) 
df_Ads = cbind(df_Ads, AdSpend.7RA = rollapplyr(df_Ads$AdSpend, 7, mean, partial = TRUE)) 


# Add 7 day rolling Average for Visits and TimeSpent
df_Traffic = cbind(df_Traffic, Visits.7RA = rollapplyr(df_Traffic$Visits, 7, mean, partial = TRUE)) 
df_Traffic = cbind(df_Traffic, TimeSpent.7RA = rollapplyr(df_Traffic$TimeSpent, 7, mean, partial = TRUE)) 
```

```{r}
# Add 4 and 7 day rolling Average for NextDayLeads for each Manual and Website Leads.
data = data %>%
  mutate(NextDayLeads.Manual.1RA = lag(NextDayLeads.Manual),
         NextDayLeads.Website.1RA = lag(NextDayLeads.Website),
         NextDayLeads.Manual.4RA = rollapplyr(NextDayLeads.Manual.1RA, 4, mean, partial = TRUE, na.rm = T), # 7 day RA for Manual Leads
         NextDayLeads.Manual.7RA = rollapplyr(NextDayLeads.Manual.1RA, 7, mean, partial = TRUE, na.rm = T), # 30 day RA for Manual Leads
         NextDayLeads.Website.4RA = rollapplyr(NextDayLeads.Website.1RA, 4, mean, partial = TRUE, na.rm = T), # 7 day RA for Website
         NextDayLeads.Website.7RA = rollapplyr(NextDayLeads.Website.1RA, 7, mean, partial = TRUE, na.rm = T)) %>% # 30 day RA for Website Leads
  fill(NextDayLeads.Manual.4RA,
       NextDayLeads.Manual.7RA,
       NextDayLeads.Website.4RA,
       NextDayLeads.Website.7RA,
       .direction = "up") %>%
  select(-NextDayLeads.Manual.1RA, -NextDayLeads.Website.1RA)
```

# 5. Data Merging
```{r}
#All Joins are Inner Joins. This way we avoid N/A values in the predictor columns. 
# Merging Website Traffic data 
data = merge(data, df_Traffic, by="Date")
# Merging Macro data 
data = merge(data, df_Macro, by="Date")
# Merging Ad data 
data = merge(data, df_Ads, by="Date")
```

# 6. Feature Engineering based on Date
```{r}
# Add Boolean feature IsNextDayWorkDay, which indicates if the NEXT day is a workday (not a weekend or a holiday). Needs Package timeDate. Also add Month Factor Feature

# Get official German Holidays (only country wide)
holidaysDE = holiday(year= c(2020,2021,2022,2023), Holiday = listHolidays("DE"))
# add column indicating if the next day is a work day and month variable
data <- data %>% 
  mutate(isNextDayWorkDay = if_else(isBizday(as.timeDate(as.Date(Date)+1),holidays = holidaysDE, wday = 1:5), 1, 0),
         month = factor(month(Date), labels = month.name))

```

# 7. Split Data frames for Manual and Website
```{r}
data_manual <- data %>%
  select(-NextDayLeads.Website) %>%
  filter(!is.na(NextDayLeads.Manual))

data_website <- data %>%
  select(-NextDayLeads.Manual) %>%
  filter(!is.na(NextDayLeads.Website))
```


# Feature Engineering with rollapply() function
```{r}
#The following graph illustrates how we came up with the width of the rolling mean. The result was then paste into the code above. 
df_manual <- data_manual %>%
  select(-NextDayLeads.Manual.4RA, -NextDayLeads.Manual.7RA, -NextDayLeads.Website.4RA, -NextDayLeads.Website.7RA) %>%
  mutate(NextDayLeads.1RA = lag(NextDayLeads.Manual)) %>%
  mutate(NextDayLeads = NextDayLeads.Manual) %>% select(-NextDayLeads.Manual)

df_website <- data_website %>%
  select(-NextDayLeads.Manual.4RA, -NextDayLeads.Manual.7RA, -NextDayLeads.Website.4RA, -NextDayLeads.Website.7RA) %>%
  mutate(NextDayLeads.1RA = lag(NextDayLeads.Website)) %>%
  mutate(NextDayLeads = NextDayLeads.Website) %>% select(-NextDayLeads.Website)

s_window <- seq(1,50,2)
df_test_manual <- tail(df_manual, 90) 
df_train_manual <- head(df_manual, -90) %>% tail(-1)
df_test_website <- tail(df_website, 90) 
df_train_website <- head(df_website, -90) %>% tail(-1)

width_model <- function(s_window, df_train, df_test) {
  prec_results <- data.frame(width = numeric(0), rmse_train = numeric(0), rmse_test = numeric(0))
  
  for (width in s_window) {
    #Create leadsLastWeek
    df_train <- df_train %>%
    mutate(leadsLastWeek = rollapply( NextDayLeads.1RA, width = width, FUN = sum, align = "right", partial = T)) %>%
      fill(leadsLastWeek, .direction = "up")
    df_test <- df_test %>%
    mutate(leadsLastWeek = rollapply( NextDayLeads.1RA, width = width, FUN = sum, align = "right", partial = T)) %>%
      fill(leadsLastWeek, .direction = "up")
    # Fit random forest model on training data
    lm_model <- lm(NextDayLeads ~ . 
                   -NextDayLeads.1RA -Date,
                   data = df_train)
    
    # Make predictions on Train & Test Data
    pred_train <- df_train %>%
    transmute(NextDayLeads,
              yhat = predict(lm_model, newdata <- df_train))
  
    pred_test <- df_test %>%
    transmute(NextDayLeads,
              yhat = predict(lm_model, newdata <- df_test))
   
    # Calculate Train & Test RMSE
    rmse_train <- sqrt( mean((pred_train$yhat - pred_train$NextDayLeads)^2))
    rmse_test <- sqrt( mean((pred_test$yhat - pred_test$NextDayLeads)^2))
  
   
      # Append results to the prec_results data frame
    prec_results <- rbind(prec_results, data.frame(width = width, train_rmse = rmse_train, test_rmse = rmse_test))
    }
  return(prec_results)
}

window_values_manual <- width_model(s_window, df_train_manual, df_test_manual)
window_values_website <- width_model(s_window, df_train_website, df_test_website)
```

#Plotting Width Tuning
```{r}
# Plot RMSE 
window_values_manual %>%
  ggplot(aes(x = width)) +
  geom_line(aes(y = train_rmse, color = "Train RMSE")) +
  geom_line(aes(y = test_rmse, color = "Test RMSE")) +
  scale_color_manual(values = c("Train RMSE" = "blue", "Test RMSE" = "red")) +
  labs(x = "Width", y = "RMSE", color = "RMSE Type") +
  ggtitle("Train/Test RMSE  vs. Rolling Average width for Manual Leads") +
  theme(
  plot.title = element_text(size = 14),
  axis.title = element_text(size = 12),
  axis.text = element_text(size = 10),
  panel.background = element_rect(fill = "white", color = NA),
  panel.grid.major = element_line(color = "gray80"),
  panel.grid.minor = element_line(color = "gray90"),
  panel.border = element_blank())

window_values_website %>%
  ggplot(aes(x = width)) +
  geom_line(aes(y = train_rmse, color = "Train RMSE")) +
  geom_line(aes(y = test_rmse, color = "Test RMSE")) +
  scale_color_manual(values = c("Train RMSE" = "blue", "Test RMSE" = "red")) +
  labs(x = "Width", y = "RMSE", color = "RMSE Type") +
  ggtitle("Train/Test RMSE  vs. Rolling average width for Website Leads") +
  theme(
  plot.title = element_text(size = 14),
  axis.title = element_text(size = 12),
  axis.text = element_text(size = 10),
  panel.background = element_rect(fill = "white", color = NA),
  panel.grid.major = element_line(color = "gray80"),
  panel.grid.minor = element_line(color = "gray90"),
  panel.border = element_blank()) + guides(color = FALSE)
```

```{r}
#Clean up workspace
rm(list = setdiff(ls(), c("data_manual", "data_website")))
```
## Modeling & Hyperparameter Tuning
```{R}
#  Test & Train Split. The last month is left as test data. All the rest is stored in the train data.
manual_train = data_manual %>% filter(Date < max(Date) %m-% months(3)) %>% select(-Date)
manual_test = data_manual %>% filter(Date > max(Date) %m-% months(3)) %>% select(-Date)
website_train = data_website %>% filter(Date < max(Date) %m-% months(3)) %>% select(-Date)
website_test = data_website %>% filter(Date > max(Date) %m-% months(3)) %>% select(-Date)

# Initialize results data frame
results_manual <- data.frame(ntrees = numeric(0), rmse.train = numeric(0), rmse.test = numeric(0))
results_website <- data.frame(ntrees = numeric(0), rmse.train = numeric(0), rmse.test = numeric(0))

# train model for different forest sizes and save results
for (ntrees in seq(1,100,3)){
  print(ntrees)
  rf.manual <- randomForest(NextDayLeads.Manual ~ . , data = manual_train, ntree = ntrees, importance = TRUE, type = Regression, nodesize =5,keep_tree = FALSE)
  rf.website <- randomForest(NextDayLeads.Website ~ ., data = website_train, ntree = ntrees, importance = TRUE, type = Regression, nodesize = 5,keep_tree = FALSE)
  
  pred.manual = mean(predict(rf.manual,newdata = manual_test,type = "response"))
  pred.website = mean(predict(rf.website,newdata = website_test, type = "response"))
  
  testRMSE.manual = sqrt(mean((manual_test$NextDayLeads.Manual - pred.manual)^2))
  testRMSE.website = sqrt(mean((website_test$NextDayLeads.Website - pred.website)^2))
  
  result_row_manual = c(ntrees, sqrt(mean(rf.manual$mse)), testRMSE.manual)
  result_row_website = c(ntrees,sqrt(mean(rf.website$mse)),testRMSE.website)
  
  results_manual[nrow(results_manual)+1,] = result_row_manual
  results_website[nrow(results_website)+1,] = result_row_website
}

```

#Plotting Ntress Tuning
```{r}
results_manual %>%
  ggplot( aes(x = ntrees)) + 
  geom_line(aes(y = rmse.train, color = "rmse.train")) +
  geom_line(aes(y = rmse.test, color = "rmse.test")) +
  scale_color_manual(values = c("rmse.train" = "blue", "rmse.test" = "red")) +
  labs(x = "Width", y = "RMSE", color = "RMSE Type") +
  ggtitle("Train/Test RMSE  vs. Ntree for Website Leads") +
  theme(
  plot.title = element_text(size = 14),
  axis.title = element_text(size = 12),
  axis.text = element_text(size = 10),
  panel.background = element_rect(fill = "white", color = NA),
  panel.grid.major = element_line(color = "gray80"),
  panel.grid.minor = element_line(color = "gray90"),
  panel.border = element_blank())

results_website %>%
  ggplot( aes(x = ntrees)) + 
  geom_line(aes(y = rmse.train, color = "Train RMSE")) +
  geom_line(aes(y = rmse.test, color = "Test RMSE")) +
  scale_color_manual(values = c("Train RMSE" = "blue", "Test RMSE" = "red")) +
  labs(x = "Width", y = "RMSE", color = "RMSE Type") +
  ggtitle("Train/Test RMSE  vs. Ntree for Website Leads") +
  theme(
  plot.title = element_text(size = 14),
  axis.title = element_text(size = 12),
  axis.text = element_text(size = 10),
  panel.background = element_rect(fill = "white", color = NA),
  panel.grid.major = element_line(color = "gray80"),
  panel.grid.minor = element_line(color = "gray90"),
  panel.border = element_blank())
```

```{r}
### check optimal node size parameter with ntree = 150
results_manual = data.frame(matrix(ncol = 3, nrow = 0))
results_website = data.frame(matrix(ncol = 3, nrow = 0))
names = c("node_size","rmse.train","rmse.test") 
colnames(results_manual) <- names
colnames(results_website) <- names
for (node_size in 1:20){
  rf.manual <- randomForest(NextDayLeads.Manual ~ . , data = manual_train, ntree = 150, importance = TRUE, type = Regression, nodesize =node_size,keep_tree = FALSE)
  rf.website <- randomForest(NextDayLeads.Website ~ ., data = website_train, ntree = 150, importance = TRUE, type = Regression, nodesize = node_size,keep_tree = FALSE)
  
  pred.manual = mean(predict(rf.manual,newdata = manual_test,type = "response"))
  pred.website = mean(predict(rf.website,newdata = website_test, type = "response"))
  
  testRMSE.manual = sqrt(mean((manual_test$NextDayLeads.Manual - pred.manual)^2))
  testRMSE.website = sqrt(mean((website_test$NextDayLeads.Website - pred.website)^2))
  
  result_row_manual = c(node_size, sqrt(mean(rf.manual$mse)), testRMSE.manual)
  result_row_website = c(node_size,sqrt(mean(rf.website$mse)),testRMSE.website)
  
  results_manual[nrow(results_manual)+1,] = result_row_manual
  results_website[nrow(results_website)+1,] = result_row_website
}
```

#Plotting Node Size Tuning
```{r}
results_manual %>%
  ggplot( aes(x = node_size)) + 
  geom_line(aes(y = rmse.train, color = "rmse.train")) +
  geom_line(aes(y = rmse.test, color = "rmse.test")) +
  scale_color_manual(values = c("rmse.train" = "blue", "rmse.test" = "red")) +
  labs(x = "Node Size", y = "RMSE", color = "RMSE Type") +
  ggtitle("Train/Test RMSE  vs. Node Size") +
  theme(
  plot.title = element_text(size = 14),
  axis.title = element_text(size = 12),
  axis.text = element_text(size = 10),
  panel.background = element_rect(fill = "white", color = NA),
  panel.grid.major = element_line(color = "gray80"),
  panel.grid.minor = element_line(color = "gray90"),
  panel.border = element_blank())

results_website %>%
  ggplot( aes(x = node_size)) + 
  geom_line(aes(y = rmse.train, color = "rmse.train")) +
  geom_line(aes(y = rmse.test, color = "rmse.test")) +
  scale_color_manual(values = c("rmse.train" = "blue", "rmse.test" = "red")) +  
  labs(x = "Node Size", y = "RMSE", color = "RMSE Type") +
  ggtitle("Train/Test RMSE  vs. Node Size") +
  theme(
  plot.title = element_text(size = 14),
  axis.title = element_text(size = 12),
  axis.text = element_text(size = 10),
  panel.background = element_rect(fill = "white", color = NA),
  panel.grid.major = element_line(color = "gray80"),
  panel.grid.minor = element_line(color = "gray90"),
  panel.border = element_blank())
```
